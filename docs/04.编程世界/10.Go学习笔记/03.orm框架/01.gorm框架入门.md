---
title: gorm框架入门
titleTag: 原创
date: 2021-07-10 23:20:16
permalink: /pages/164926/
categories: 
  - 编程世界
  - Go学习笔记
  - orm框架
tags: 
  - null

description: 
---



gorm是一个使用Go语言编写的ORM框架。它文档齐全，对开发者友好，支持主流数据库。

## 1，gorm介绍

[Github GORM](https://github.com/jinzhu/gorm)

[中文官方网站](https://gorm.io/zh_CN/)内含十分齐全的中文文档，有了它你甚至不需要再继续向下阅读本文。

## 2，安装

```bash
go get -u github.com/jinzhu/gorm
```

## 3，连接数据库

连接不同的数据库都需要导入对应数据的驱动程序，`GORM`已经贴心的为我们包装了一些驱动程序，只需要按如下方式导入需要的数据库驱动即可：

```go
import _ "github.com/jinzhu/gorm/dialects/mysql"
// import _ "github.com/jinzhu/gorm/dialects/postgres"
// import _ "github.com/jinzhu/gorm/dialects/sqlite"
// import _ "github.com/jinzhu/gorm/dialects/mssql"
```

### 1，连接MySQL

```go
import (
  "github.com/jinzhu/gorm"
  _ "github.com/jinzhu/gorm/dialects/mysql"
)

func main() {
  db, err := gorm.Open("mysql", "user:password@(localhost)/dbname?charset=utf8mb4&parseTime=True&loc=Local")
  defer db.Close()
}
```

### 2，连接PostgreSQL

基本代码同上，注意引入对应`postgres`驱动并正确指定`gorm.Open()`参数。

```go
import (
  "github.com/jinzhu/gorm"
  _ "github.com/jinzhu/gorm/dialects/postgres"
)

func main() {
  db, err := gorm.Open("postgres", "host=myhost port=myport user=gorm dbname=gorm password=mypassword")
  defer db.Close()
}
```

### 3，连接Sqlite3

基本代码同上，注意引入对应`sqlite`驱动并正确指定`gorm.Open()`参数。

```go
import (
  "github.com/jinzhu/gorm"
  _ "github.com/jinzhu/gorm/dialects/sqlite"
)

func main() {
  db, err := gorm.Open("sqlite3", "/tmp/gorm.db")
  defer db.Close()
}
```

### 4，连接SQL Server

基本代码同上，注意引入对应`mssql`驱动并正确指定`gorm.Open()`参数。

```go
import (
  "github.com/jinzhu/gorm"
  _ "github.com/jinzhu/gorm/dialects/mssql"
)

func main() {
  db, err := gorm.Open("mssql", "sqlserver://username:password@localhost:1433?database=dbname")
  defer db.Close()
}
```

## 4，GORM基本示例

**注意:**

1. 本文以MySQL数据库为例，讲解GORM各项功能的主要使用方法。
2. 往下阅读本文前，你需要有一个能够成功连接上的MySQL数据库实例。

### 1，Docker快速创建MySQL实例

很多同学如果不会安装MySQL或者懒得安装MySQL，可以使用一下命令快速运行一个MySQL8.0.19实例，当然前提是你要有docker环境…

在本地的`13306`端口运行一个名为`mysql8019`，root用户名密码为`root1234`的MySQL容器环境:

```bash
docker run --name mysql8019 -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root1234 -d mysql:8.0.19
```

在另外启动一个`MySQL Client`连接上面的MySQL环境，密码为上一步指定的密码`root1234`:

```bash
docker run -it --network host --rm mysql mysql -h127.0.0.1 -P13306 --default-character-set=utf8mb4 -uroot -p
```

### 2，创建数据库

在使用GORM前手动创建数据库`db1`：

```sql
CREATE DATABASE db1;
```

### 3，GORM操作MySQL

使用GORM连接上面的`db1`进行创建、查询、更新、删除操作。

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

type UserInfo struct {
	Id     uint
	Name   string
	Gender string
	Hobby  string
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 创建表，自动迁移（把结构体和数据表进行对应）
	db.AutoMigrate(&UserInfo{})

	// 创建数据行
	//u1 := UserInfo{1, "eryajf", "男", "篮球"}
	//db.Create(&u1)

	// 查询数据
	var u UserInfo
	db.First(&u) //查询表中第一条数据保存到u中
	fmt.Printf("u:%#v\n", u)

	// 更新数据
	db.Model(&u).Update("hobby", "双色球")

	// 删除数据
	db.Delete(&u)
}
```

## 5，GORM Model定义

在使用ORM工具时，通常我们需要在代码中定义模型（Models）与数据库中的数据表进行映射，在GORM中模型（Models）通常是正常定义的结构体、基本的go类型或它们的指针。 同时也支持`sql.Scanner`及`driver.Valuer`接口（interfaces）。

### 1，gorm.Model

为了方便模型定义，GORM内置了一个`gorm.Model`结构体。`gorm.Model`是一个包含了`ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`四个字段的Golang结构体。

```go
// gorm.Model 定义
type Model struct {
  ID        uint `gorm:"primary_key"`
  CreatedAt time.Time
  UpdatedAt time.Time
  DeletedAt *time.Time
}
```

你可以将它嵌入到你自己的模型中：

```go
// 将 `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`字段注入到`User`模型中
type User struct {
  gorm.Model
  Name string
}
```

当然你也可以完全自己定义模型：

```go
// 不使用gorm.Model，自行定义模型
type User struct {
  ID   int
  Name string
}
```

### 2，模型定义示例

```go
type User struct {
  gorm.Model
  Name         string
  Age          sql.NullInt64
  Birthday     *time.Time
  Email        string  `gorm:"type:varchar(100);unique_index"`
  Role         string  `gorm:"size:255"` // 设置字段大小为255
  MemberNumber *string `gorm:"unique;not null"` // 设置会员号（member number）唯一并且不为空
  Num          int     `gorm:"AUTO_INCREMENT"` // 设置 num 为自增类型
  Address      string  `gorm:"index:addr"` // 给address字段创建名为addr的索引
  IgnoreMe     int     `gorm:"-"` // 忽略本字段
}
```

### 3，结构体标记（tags）

使用结构体声明模型时，标记（tags）是可选项。gorm支持以下标记:

#### 1，支持的结构体标记（Struct tags）

| 结构体标记（Tag） | 描述                                                     |
| ----------------: | :------------------------------------------------------- |
|            Column | 指定列名                                                 |
|              Type | 指定列数据类型                                           |
|              Size | 指定列大小, 默认值255                                    |
|       PRIMARY_KEY | 将列指定为主键                                           |
|            UNIQUE | 将列指定为唯一                                           |
|           DEFAULT | 指定列默认值                                             |
|         PRECISION | 指定列精度                                               |
|          NOT NULL | 将列指定为非 NULL                                        |
|    AUTO_INCREMENT | 指定列是否为自增类型                                     |
|             INDEX | 创建具有或不带名称的索引, 如果多个索引同名则创建复合索引 |
|      UNIQUE_INDEX | 和 `INDEX` 类似，只不过创建的是唯一索引                  |
|          EMBEDDED | 将结构设置为嵌入                                         |
|   EMBEDDED_PREFIX | 设置嵌入结构的前缀                                       |
|                 - | 忽略此字段                                               |

#### 2，关联相关标记（tags）

|                结构体标记（Tag） | 描述                               |
| -------------------------------: | :--------------------------------- |
|                        MANY2MANY | 指定连接表                         |
|                       FOREIGNKEY | 设置外键                           |
|           ASSOCIATION_FOREIGNKEY | 设置关联外键                       |
|                      POLYMORPHIC | 指定多态类型                       |
|                POLYMORPHIC_VALUE | 指定多态值                         |
|             JOINTABLE_FOREIGNKEY | 指定连接表的外键                   |
| ASSOCIATION_JOINTABLE_FOREIGNKEY | 指定连接表的关联外键               |
|                SAVE_ASSOCIATIONS | 是否自动完成 save 的相关操作       |
|           ASSOCIATION_AUTOUPDATE | 是否自动完成 update 的相关操作     |
|           ASSOCIATION_AUTOCREATE | 是否自动完成 create 的相关操作     |
|       ASSOCIATION_SAVE_REFERENCE | 是否自动完成引用的 save 的相关操作 |
|                          PRELOAD | 是否自动完成预加载的相关操作       |

## 6，主键、表名、列名的约定

### 1，主键（Primary Key）

GORM 默认会使用名为ID的字段作为表的主键。

```go
type User struct {
  ID   string // 名为`ID`的字段会默认作为表的主键
  Name string
}

// 使用`AnimalID`作为主键
type Animal struct {
  AnimalID int64 `gorm:"primary_key"`
  Name     string
  Age      int64
}
```

### 2，表名（Table Name）

表名默认就是结构体名称的复数，例如：

```go
type User struct {} // 默认表名是 `users`

// 方法一：将 User 的表名设置为 `profiles`
func (User) TableName() string {
  return "profiles"
}

func (u User) TableName() string {
  if u.Role == "admin" {
    return "admin_users"
  } else {
    return "users"
  }
}

// 方法二：禁用默认表名的复数形式，如果置为 true，则 `User` 的默认表名是 `user`
db.SingularTable(true)
```

也可以通过`Table()`指定表名：

```go
// 方法三：使用User结构体创建名为`deleted_users`的表
db.Table("deleted_users").CreateTable(&User{})

var deleted_users []User
db.Table("deleted_users").Find(&deleted_users)
//// SELECT * FROM deleted_users;

db.Table("deleted_users").Where("name = ?", "jinzhu").Delete()
//// DELETE FROM deleted_users WHERE name = 'jinzhu';
```

GORM还支持更改默认表名称规则：

```go
gorm.DefaultTableNameHandler = func (db *gorm.DB, defaultTableName string) string  {
  return "prefix_" + defaultTableName;
}
```

### 3，列名（Column Name）

列名由字段名称进行下划线分割来生成

```go
type User struct {
  ID        uint      // column name is `id`
  Name      string    // column name is `name`
  Birthday  time.Time // column name is `birthday`
  CreatedAt time.Time // column name is `created_at`
}
```

可以使用结构体tag指定列名：

```go
type Animal struct {
  AnimalId    int64     `gorm:"column:beast_id"`         // set column name to `beast_id`
  Birthday    time.Time `gorm:"column:day_of_the_beast"` // set column name to `day_of_the_beast`
  Age         int64     `gorm:"column:age_of_the_beast"` // set column name to `age_of_the_beast`
}
```

### 4，时间戳跟踪

#### 1，CreatedAt

如果模型有 `CreatedAt`字段，该字段的值将会是初次创建记录的时间。

```go
db.Create(&user) // `CreatedAt`将会是当前时间

// 可以使用`Update`方法来改变`CreateAt`的值
db.Model(&user).Update("CreatedAt", time.Now())
```

#### 2，UpdatedAt

如果模型有`UpdatedAt`字段，该字段的值将会是每次更新记录的时间。

```go
db.Save(&user) // `UpdatedAt`将会是当前时间

db.Model(&user).Update("name", "jinzhu") // `UpdatedAt`将会是当前时间
```

#### 3，DeletedAt

如果模型有`DeletedAt`字段，调用`Delete`删除该记录时，将会设置`DeletedAt`字段为当前时间，而不是直接将记录从数据库中删除。

CRUD通常指数据库的增删改查操作，本文详细介绍了如何使用GORM实现创建、查询、更新和删除操作。

## 7，创建

### 1，创建记录

首先定义模型：

```go
type User struct {
	ID           int64
	Name         string
	Age          int64
}
```

使用使用`NewRecord()`查询主键是否存在，主键为空使用`Create()`创建记录：

```go
u := User{Name: "eryajf", Age: 20} //结构体的初始化，相当于创建了一条用户数据

fmt.Println(db.NewRecord(&u))      //判断主键是否为空 true
db.Create(&u)                      //将上边定义的用户数据写入到数据库user表中
fmt.Println(db.NewRecord(&u))      //判断主键是否为空 false
```

### 2，默认值

可以通过 tag 定义字段的默认值，比如：

```go
type User struct {
	ID   int64
	Name sql.NullString `gorm:"default:'eryajf'"`
	Age  int64
}
```

**注意：**通过tag定义字段的默认值，在创建记录时候生成的 SQL 语句会排除没有值或值为 零值 的字段。 在将记录插入到数据库后，Gorm会从数据库加载那些字段的默认值。

举个例子：

```go
var user = User{Name: "", Age: 99}
db.Create(&user)
```

上面代码实际执行的SQL语句是`INSERT INTO users("age") values('99');`，排除了零值字段`Name`，而在数据库中这一条数据会使用设置的默认值`eryajf`作为Name字段的值。

> **注意：**所有字段的零值, 比如`0`, `""`,`false`或者其它`零值`，都不会保存到数据库内，但会使用他们的默认值。 如果你想避免这种情况，可以考虑使用指针或实现 `Scanner/Valuer`接口

#### 1，使用指针方式实现零值存入数据库

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	ID   int64
	Name *string `gorm:"default:'eryajf'"`
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)

	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})

	u4 := User{Age: 24, Name: new(string)}
	fmt.Println(db.NewRecord(&u4))
	db.Debug().Create(&u4) // INSERT INTO `user` (`name`,`age`) VALUES ('',24)
	fmt.Println(db.NewRecord(&u4))
}
```

#### 2，使用Scanner/Valuer接口方式实现零值存入数据库

```go
package main

import (
	"database/sql"
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	ID   int64
	Name sql.NullString `gorm:"default:'eryajf'"`
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)

	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})

	u4 := User{Age: 24, Name: sql.NullString{String: "", Valid: true}}
	fmt.Println(db.NewRecord(&u4))
	db.Debug().Create(&u4) // INSERT INTO `user` (`name`,`age`) VALUES ('',24)
	fmt.Println(db.NewRecord(&u4))
}
```

### 3，扩展创建选项

例如`PostgreSQL`数据库中可以使用下面的方式实现合并插入, 有则更新, 无则插入。

```go
// 为Instert语句添加扩展SQL选项
db.Set("gorm:insert_option", "ON CONFLICT").Create(&product)
// INSERT INTO products (name, code) VALUES ("name", "code") ON CONFLICT;
```

## 8，查询

### 1，普通查询

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name string
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)
	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})
	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22}
	//db.Create(&u2)

	// 4,查询
	var user []User
	db.Debug().First(&user) // SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("根据主键查询第一条记录：", user)

	db.Debug().Take(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL LIMIT 1
	fmt.Println("随机获取一条记录：", user)

	db.Debug().Last(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL ORDER BY `user`.`id` DESC LIMIT 1
	fmt.Println("根据主键查询最后一条记录：", user)

	db.Debug().Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL
	fmt.Println("查询所有的记录：", user)

	db.Debug().First(&user, 2)      //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`id` = 2)) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("查询指定的某条记录：", user) //仅当主键为整型时可用

}
```

### 2，Where 条件

#### 2，普通SQL查询

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
	"time"
)

// 定义模型
type User struct {
	gorm.Model
	Name string
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)
	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})
	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22}
	//db.Create(&u2)

	// 4,查询	// Where
	var user []User
	db.Debug().Where("name = ?", "jinzhu").First(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((name = 'jinzhu')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("查询第一条匹配条件记录：", user)

	db.Debug().Where("name = ?", "jinzhu").Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((name = 'jinzhu'))
	fmt.Println("查询所有匹配条件的记录：", user)

	db.Debug().Where("name <> ?", "jinzhu").Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((name <> 'jinzhu'))
	fmt.Println("查询name不等于jinzhu的所有记录：", user)

	db.Debug().Where("name IN (?)", []string{"jinzhu", "jinzhu 2"}).Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((name IN ('jinzhu','jinzhu 2')))
	fmt.Println("查询name在jinzhu和jinzhu 2的所有记录：", user)

	db.Debug().Where("name LIKE ?", "%jin%").Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((name LIKE '%jin%'))
	fmt.Println("查询name包含jin的所有记录：", user)

	db.Debug().Where("name = ? AND age >= ?", "jinzhu", "20").Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((name = 'jinzhu' AND age >= '20'))
	fmt.Println("查询两个条件都符合的所有记录：", user)

	oneDay, _ := time.ParseDuration("-24h")
	lastWeek := time.Now().Add(oneDay * 7)
	db.Debug().Where("updated_at > ?", lastWeek).Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((updated_at > '2020-03-01 19:45:11'))
	fmt.Println("查询一周内更新的用户记录：", user)

	today := time.Now()
	db.Debug().Where("created_at BETWEEN ? AND ?", lastWeek, today).Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((created_at BETWEEN '2020-03-01 19:52:51' AND '2020-03-08 19:52:51'))
	fmt.Println("查询一周内创建的记录：", user)

}
```

#### 2，Struct & Map查询

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name string
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)
	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})
	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22}
	//db.Create(&u2)

	// 4,查询
	var user []User
	db.Debug().Where(&User{Name: "jinzhu", Age: 22}).First(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'jinzhu') AND (`user`.`age` = 22)) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("通过结构体查询：", user)

	db.Debug().Where(map[string]interface{}{"name": "jinzhu", "age": 22}).Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'jinzhu') AND (`user`.`age` = 22))
	fmt.Println("通过map查询：", user)

	db.Debug().Where([]int64{1, 2}).Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`id` IN (1,2)))
	fmt.Println("通过主键的切片查询：", user)
}
```

**提示：**当通过结构体进行查询时，GORM将会只通过非零值字段查询，这意味着如果你的字段值为`0`，`''`，`false`或者其他`零值`时，将不会被用于构建查询条件，例如：

```go
db.Where(&User{Name: "jinzhu", Age: 0}).Find(&users)  // SELECT * FROM users WHERE name = "jinzhu";
```

此时，就像创建一样，你可以使用指针或实现 Scanner/Valuer 接口来避免这个问题.

```go
// 使用指针
type User struct {
  gorm.Model
  Name string
  Age  *int
}

// 使用 Scanner/Valuer
type User struct {
  gorm.Model
  Name string
  Age  sql.NullInt64  // sql.NullInt64 实现了 Scanner/Valuer 接口
}
```

### 3，Not 条件

作用与 Where 类似的情形如下：

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name string
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)
	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})
	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22}
	//db.Create(&u2)

	// 4,查询
	var user []User

	db.Debug().Not("name", "jinzhu").First(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` NOT IN ('jinzhu'))) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("查询name不是jinzhu的第一条记录：", user)

	db.Debug().Not("name", []string{"jinzhu", "jinzhu 2"}).Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` NOT IN ('jinzhu','jinzhu 2')))
	fmt.Println("查询name不在jinzhu或jinzhu2的所有记录：", user)

	db.Debug().Not([]int64{1, 2, 3}).Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`id` NOT IN (1,2,3)))
	fmt.Println("查询主键不是1，2，3的所有记录：", user)

	db.Debug().Not([]int64{}).First(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("查询所有用户中的第一个：", user)

	db.Debug().Not("name = ?", "jinzhu").First(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND (NOT (name = 'jinzhu')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("查询name不是jinzhu的第一个用户：", user)

	db.Debug().Not(User{Name: "jinzhu"}).First(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` <> 'jinzhu')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("通过结构体查询name不是jinzhu的第一个用户：", user)

}
```

### 4，Or条件

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name string
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)
	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})
	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22}
	//db.Create(&u2)

	// 4,查询
	var user []User

	db.Debug().Where("age > ?", 25).Or("age < ?", 23).Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((age > 25) OR (age < 23))
	fmt.Println("查询年龄小于23的或者大于25的所有记录：", user)

	// struct
	db.Debug().Where("name = 'jinzhu'").Or(User{Name: "jinzhu 2"}).Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((name = 'jinzhu') OR (`user`.`name` = 'jinzhu 2'))
	fmt.Println("结构体：查询名字是jinzhu的或者是jinzhu 2的所有记录：", user)

	// map
	db.Debug().Where("name = 'jinzhu'").Or(map[string]interface{}{"name": "jinzhu 2"}).Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((name = 'jinzhu') OR (`user`.`name` = 'jinzhu 2'))
	fmt.Println("map：查询名字是jinzhu的或者是jinzhu 2的所有记录：", user)
}
```

### 5，内联条件

作用与`Where`查询类似，当内联条件与多个[立即执行方法](https://www.liwenzhou.com/posts/Go/gorm_crud/#autoid-1-3-1)一起使用时, 内联条件不会传递给后面的立即执行方法。

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name string
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)
	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})
	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22}
	//db.Create(&u2)

	// 4,查询
	var user []User

	db.Debug().First(&user, 3)          //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`id` = 3)) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("根据主键查询指定的某条记录：", user) //仅当主键为整型时可用

	db.Debug().First(&user, "id = ?", "string_primary_key") //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((id = 'string_primary_key')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("根据主键是非整形主键获取记录：", user)

	db.Debug().Find(&user, "name = ?", "jinzhu") //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((name = 'jinzhu'))
	fmt.Println("查询name为jinzhu的记录：", user)

	db.Debug().Find(&user, "name <> ? AND age > ? ", "jinzhu", "20") //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((name <> 'jinzhu' AND age > '20' ))
	fmt.Println("查询name不是jinzhu且年龄大于20的记录：", user)

	db.Debug().Find(&user, User{Age: 20}) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`age` = 20))
	fmt.Println("通过结构体查询年龄是20的所有记录：", user)

	db.Debug().Find(&user, map[string]interface{}{"age": 20}) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`age` = 20))
	fmt.Println("通过map查询年龄是20的所有记录：", user)

}
```

### 6，额外查询选项

```go
// 为查询 SQL 添加额外的 SQL 操作
db.Set("gorm:query_option", "FOR UPDATE").First(&user, 10)
//// SELECT * FROM users WHERE id = 10 FOR UPDATE;
```

### 7，FirstOrInit

获取匹配的第一条记录，否则根据给定的条件初始化一个新的对象 (仅支持 struct 和 map 条件)

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name string
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)
	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})
	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22}
	//db.Create(&u2)

	// 4,查询
	var user []User

	db.Debug().FirstOrInit(&user, User{Name: "non_existing"}) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'non_existing')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("查询name为non_existing的记录：", user)

	db.Debug().Where(User{Name: "jinzhu"}).FirstOrInit(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'jinzhu')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("通过结构体查询name为jinzhu的记录：", user)

	db.Debug().FirstOrInit(&user, map[string]interface{}{"name": "jinzhu"}) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'jinzhu')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println("通过map查询name为jinzhu的记录：", user)

}
```

#### 1，Attrs

如果记录未找到，将使用参数初始化 struct.

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name string
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)
	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})
	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22}
	//db.Create(&u2)

	// 4,查询
	var user []User

	// 未找到
	db.Debug().Where(User{Name: "non_existing"}).Attrs(User{Age: 20}).FirstOrInit(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'non_existing')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println(user)

	db.Debug().Where(User{Name: "non_existing"}).Attrs("age", 20).FirstOrInit(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'non_existing')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println(user)

	// 找到
	db.Debug().Where(User{Name: "jinzhu"}).Attrs(User{Age: 50}).FirstOrInit(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'jinzhu')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println(user)

}
```

#### 2，Assign

不管记录是否找到，都将参数赋值给 struct.

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name string
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)
	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})
	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22}
	//db.Create(&u2)

	// 4,查询
	var user []User

	db.Debug().Where(User{Name: "non_existing"}).Assign(User{Age: 20}).FirstOrInit(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'non_existing')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println(user)

	// 找到
	db.Debug().Where(User{Name: "jinzhu"}).Assign(User{Age: 50}).FirstOrInit(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'jinzhu')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println(user)

}
```

### 8，FirstOrCreate

获取匹配的第一条记录, 否则根据给定的条件创建一个新的记录 (仅支持 struct 和 map 条件)

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name string
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)
	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})
	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22}
	//db.Create(&u2)

	// 4,查询
	var user []User

	db.Debug().FirstOrCreate(&user, User{Name: "non_existing"}) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'non_existing')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println(user)

	db.Debug().Where(User{Name: "jinzhu"}).FirstOrCreate(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'jinzhu')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println(user)
}
```

#### 1，Attrs

如果记录未找到，将使用参数创建 struct 和记录.

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name string
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)
	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})
	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22}
	//db.Create(&u2)

	// 4,查询
	var user []User

	db.Debug().Where(User{Name: "non_existing"}).Attrs(User{Age: 20}).FirstOrCreate(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'non_existing')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println(user)

	db.Debug().Where(User{Name: "jinzhu"}).Attrs(User{Age: 30}).FirstOrCreate(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`user`.`name` = 'jinzhu')) ORDER BY `user`.`id` ASC LIMIT 1
	fmt.Println(user)
}

```

#### 2，Assign

不管记录是否找到，都将参数赋值给 struct 并保存至数据库.

```go
// 未找到
db.Where(User{Name: "non_existing"}).Assign(User{Age: 20}).FirstOrCreate(&user)
//// SELECT * FROM users WHERE name = 'non_existing';
//// INSERT INTO "users" (name, age) VALUES ("non_existing", 20);
//// user -> User{Id: 112, Name: "non_existing", Age: 20}

// 找到
db.Where(User{Name: "jinzhu"}).Assign(User{Age: 30}).FirstOrCreate(&user)
//// SELECT * FROM users WHERE name = 'jinzhu';
//// UPDATE users SET age=30 WHERE id = 111;
//// user -> User{Id: 111, Name: "jinzhu", Age: 30}
```

### 9，高级查询

#### 1，子查询

基于 `*gorm.expr` 的子查询

```go
db.Where("amount > ?", DB.Table("orders").Select("AVG(amount)").Where("state = ?", "paid").QueryExpr()).Find(&orders)
// SELECT * FROM "orders"  WHERE "orders"."deleted_at" IS NULL AND (amount > (SELECT AVG(amount) FROM "orders"  WHERE (state = 'paid')));
```

#### 2，选择字段

Select，指定你想从数据库中检索出的字段，默认会选择全部字段。

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name string
	Age  int64
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)
	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})
	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22}
	//db.Create(&u2)

	// 4,查询
	var user []User

	db.Debug().Select("name", "age").Find(&user) //SELECT name FROM `user`  WHERE `user`.`deleted_at` IS NULL'age'
	fmt.Println("查询表中name字段参数为age的记录：", user)

	db.Debug().Select([]string{"name", "age"}).Find(&user) //SELECT name, age FROM `user`  WHERE `user`.`deleted_at` IS NULL
	fmt.Println("列出表中name与age字段：", user)

}
```

#### 3，排序

Order，指定从数据库中检索出记录的顺序。设置第二个参数 reorder 为 `true` ，可以覆盖前面定义的排序条件。

```go
db.Order("age desc, name").Find(&users)
//// SELECT * FROM users ORDER BY age desc, name;

// 多字段排序
db.Order("age desc").Order("name").Find(&users)
//// SELECT * FROM users ORDER BY age desc, name;

// 覆盖排序
db.Order("age desc").Find(&users1).Order("age", true).Find(&users2)
//// SELECT * FROM users ORDER BY age desc; (users1)
//// SELECT * FROM users ORDER BY age; (users2)
```

#### 4，数量

Limit，指定从数据库检索出的最大记录数。

```go
db.Limit(3).Find(&users)
//// SELECT * FROM users LIMIT 3;

// -1 取消 Limit 条件
db.Limit(10).Find(&users1).Limit(-1).Find(&users2)
//// SELECT * FROM users LIMIT 10; (users1)
//// SELECT * FROM users; (users2)
```

#### 5，偏移

Offset，指定开始返回记录前要跳过的记录数。

```go
db.Offset(3).Find(&users)
//// SELECT * FROM users OFFSET 3;

// -1 取消 Offset 条件
db.Offset(10).Find(&users1).Offset(-1).Find(&users2)
//// SELECT * FROM users OFFSET 10; (users1)
//// SELECT * FROM users; (users2)
```

#### 6，总数

Count，该 model 能获取的记录总数。

```go
db.Where("name = ?", "jinzhu").Or("name = ?", "jinzhu 2").Find(&users).Count(&count)
//// SELECT * from USERS WHERE name = 'jinzhu' OR name = 'jinzhu 2'; (users)
//// SELECT count(*) FROM users WHERE name = 'jinzhu' OR name = 'jinzhu 2'; (count)

db.Model(&User{}).Where("name = ?", "jinzhu").Count(&count)
//// SELECT count(*) FROM users WHERE name = 'jinzhu'; (count)

db.Table("deleted_users").Count(&count)
//// SELECT count(*) FROM deleted_users;

db.Table("deleted_users").Select("count(distinct(name))").Count(&count)
//// SELECT count( distinct(name) ) FROM deleted_users; (count)
```

**注意** `Count` 必须是链式查询的最后一个操作 ，因为它会覆盖前面的 `SELECT`，但如果里面使用了 `count` 时不会覆盖

#### 7，Group & Having

```go
rows, err := db.Table("orders").Select("date(created_at) as date, sum(amount) as total").Group("date(created_at)").Rows()
for rows.Next() {
  ...
}

// 使用Scan将多条结果扫描进事先准备好的结构体切片中
type Result struct {
	Date time.Time
	Total int
}
var rets []Result
db.Table("users").Select("date(created_at) as date, sum(age) as total").Group("date(created_at)").Scan(&rets)

rows, err := db.Table("orders").Select("date(created_at) as date, sum(amount) as total").Group("date(created_at)").Having("sum(amount) > ?", 100).Rows()
for rows.Next() {
  ...
}

type Result struct {
  Date  time.Time
  Total int64
}
db.Table("orders").Select("date(created_at) as date, sum(amount) as total").Group("date(created_at)").Having("sum(amount) > ?", 100).Scan(&results)
```

#### 8，连接

Joins，指定连接条件

```go
rows, err := db.Table("users").Select("users.name, emails.email").Joins("left join emails on emails.user_id = users.id").Rows()
for rows.Next() {
  ...
}

db.Table("users").Select("users.name, emails.email").Joins("left join emails on emails.user_id = users.id").Scan(&results)

// 多连接及参数
db.Joins("JOIN emails ON emails.user_id = users.id AND emails.email = ?", "jinzhu@example.org").Joins("JOIN credit_cards ON credit_cards.user_id = users.id").Where("credit_cards.number = ?", "411111111111").Find(&user)
```

#### 9，Pluck

Pluck，查询 model 中的一个列作为切片，如果您想要查询多个列，您应该使用 [`Scan`](https://www.liwenzhou.com/posts/Go/gorm_crud/#Scan)

```go
var ages []int64
db.Find(&users).Pluck("age", &ages)

var names []string
db.Model(&User{}).Pluck("name", &names)

db.Table("deleted_users").Pluck("name", &names)

// 想查询多个字段？ 这样做：
db.Select("name, age").Find(&users)
```

#### 10，扫描

Scan，扫描结果至一个 struct.

```go
type Result struct {
  Name string
  Age  int
}

var result Result
db.Table("users").Select("name, age").Where("name = ?", "Antonio").Scan(&result)

var results []Result
db.Table("users").Select("name, age").Where("id > ?", 0).Scan(&results)

// 原生 SQL
db.Raw("SELECT name, age FROM users WHERE name = ?", "Antonio").Scan(&result)
```

## 9，更新

### 1，更新所有字段

`Save()`默认会更新该对象的所有字段，即使你没有赋值。

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 1,定义模型
type User struct {
	ID     int64
	Name   string
	Age    int64
	Active bool
}

func main() {
	// 2, 连接数据库
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)

	// 3, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})

	// 4, 创建
	//u1 := User{Name: "eryajf", Age: 20, Active: true}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22, Active: false}
	//db.Create(&u2)

	// 5, 查询
	var user User
	db.First(&user)
	fmt.Println(user)

	// 6, 更新
	user.Name = "二丫讲梵"
	user.Age = 20
	// save 默认会更新该对象的所有字段，即使没有赋值
	db.Debug().Save(&user) //UPDATE `user` SET `name` = '二丫讲梵', `age` = 20, `active` = true  WHERE `user`.`id` = 1

}
```

### 2，更新修改字段

如果你只希望更新指定字段，可以使用`Update`或者`Updates`

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 1,定义模型
type User struct {
	ID     int64
	Name   string
	Age    int64
	Active bool
}

func main() {
	// 2, 连接数据库
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)

	// 3, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})

	// 4, 创建
	//u1 := User{Name: "eryajf", Age: 20, Active: true}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22, Active: false}
	//db.Create(&u2)

	// 5, 查询
	var user User
	db.First(&user)
	fmt.Println(user)

	// 6, 更新
	// 更新单个属性，如果他有变化
	db.Debug().Model(&user).Update("name", "hello") //UPDATE `user` SET `name` = 'hello'  WHERE `user`.`id` = 1

	// 根据给定的条件更新单个属性
	db.Debug().Model(&user).Where("active = ?", true).Update("name", "hello") //UPDATE `user` SET `name` = 'hello'  WHERE `user`.`id` = 1 AND ((active = true))

	// 使用map 更新多个属性，只会更新其中有变化的属性
	db.Debug().Model(&user).Updates(map[string]interface{}{"name": "hello", "age": 18, "active": "false"}) //UPDATE `user` SET `active` = true, `age` = 18, `name` = 'hello'  WHERE `user`.`id` = 1

	// 使用struct 更新多个属性，只会更新其中有变化且为非零值的字段
	db.Debug().Model(&user).Updates(User{Name: "hello", Age: 23}) //UPDATE `user` SET `age` = 23, `name` = 'hello'  WHERE `user`.`id` = 1

	// 警告：当使用struct更新时，GORM只会更新那些非零值的字段
	// 对于下面的操作，不会发生任何更新
	db.Debug().Model(&user).Updates(User{Name: "", Age: 0, Active: false})
	//db.Debug().Model(&user)
}
```

### 3，更新选定字段

如果你想更新或忽略某些字段，你可以使用 `Select`，`Omit`

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 1,定义模型
type User struct {
	ID     int64
	Name   string
	Age    int64
	Active bool
}

func main() {
	// 2, 连接数据库
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)

	// 3, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})

	// 4, 创建
	//u1 := User{Name: "eryajf", Age: 20, Active: true}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22, Active: false}
	//db.Create(&u2)

	// 5, 查询
	var user User
	db.First(&user)
	fmt.Println(user)

	// 6, 更新
	m1 := map[string]interface{}{
		"name":   "liqilong",
		"age":    20,
		"active": true,
	}

	// 选择 m1 中某个字段进行更新
	db.Debug().Model(&user).Select("name").Updates(m1) //UPDATE `user` SET `name` = 'liqilong'  WHERE `user`.`id` = 1

	// 忽略 m1 中active字段更新其他字段
	db.Debug().Model(&user).Omit("active").Updates(m1) //UPDATE `user` SET `age` = 20, `name` = 'liqilong'  WHERE `user`.`id` = 1
}
```

### 4，无Hooks更新

上面的更新操作会自动运行 model 的 `BeforeUpdate`, `AfterUpdate` 方法，更新 `UpdatedAt` 时间戳, 在更新时保存其 `Associations`, 如果你不想调用这些方法，你可以使用 `UpdateColumn`， `UpdateColumns`

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 1,定义模型
type User struct {
	ID     int64
	Name   string
	Age    int64
	Active bool
}

func main() {
	// 2, 连接数据库
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)

	// 3, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})

	// 4, 创建
	//u1 := User{Name: "eryajf", Age: 20, Active: true}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22, Active: false}
	//db.Create(&u2)

	// 5, 查询
	var user User
	db.First(&user)
	fmt.Println(user)

	// 6, 更新

	// 更新单个属性，类似于 update
	db.Debug().Model(&user).UpdateColumn("name", "hello") //UPDATE `user` SET `name` = 'hello'  WHERE `user`.`id` = 1
	// 更新多个属性，类似于 updates
	db.Debug().Model(&user).UpdateColumns(User{Name: "hello", Age: 18}) //UPDATE `user` SET `age` = 18, `name` = 'hello'  WHERE `user`.`id` = 1

}
```

### 5，批量更新

批量更新时`Hooks（钩子函数）`不会运行。

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 1,定义模型
type User struct {
	ID     int64
	Name   string
	Age    int64
	Active bool
}

func main() {
	// 2, 连接数据库
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)

	// 3, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})

	// 4, 创建
	//u1 := User{Name: "eryajf", Age: 20, Active: true}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22, Active: false}
	//db.Create(&u2)

	// 5, 查询
	var user User
	db.First(&user)
	fmt.Println(user)

	// 6, 更新

	db.Debug().Table("user").Where("id IN (?)", []int{10, 11}).Updates(map[string]interface{}{"name": "hello", "age": 20}) //UPDATE `user` SET `age` = 20, `name` = 'hello'  WHERE (id IN (10,11))
	// 使用struct更新时，只会更新非零值字段，若想更新所有字段，应使用如上map方式
	db.Debug().Model(User{}).Updates(User{Name: "hello", Age: 23}) //UPDATE `user` SET `age` = 23, `name` = 'hello'

	// 使用 RowsAffected 获取更新记录总数
	chageNum := db.Debug().Model(User{}).Updates(User{Name: "hello", Age: 23}).RowsAffected //UPDATE `user` SET `age` = 23, `name` = 'hello'
	fmt.Println(chageNum)

	//db.Debug().Model(&user)
}
```

### 6，使用SQL表达式更新

先查询表中的第一条数据保存至user变量。

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 1,定义模型
type User struct {
	ID     int64
	Name   string
	Age    int64
	Active bool
}

func main() {
	// 2, 连接数据库
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)

	// 3, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})

	// 4, 创建
	//u1 := User{Name: "eryajf", Age: 20, Active: true}
	//db.Create(&u1)
	//u2 := User{Name: "jinzhu", Age: 22, Active: false}
	//db.Create(&u2)

	// 5, 查询
	var user User
	db.First(&user)
	fmt.Println(user)

	// 6, 更新

	// 给匹配到的用户增加3岁
	db.Debug().Model(&user).Update("age", gorm.Expr("age + ?", 3)) //UPDATE `user` SET `age` = age + 3  WHERE `user`.`id` = 1
	// 以map的方式进行年龄运算
	db.Debug().Model(&user).Updates(map[string]interface{}{"age": gorm.Expr("age * ? + ?", 2, 100)}) //UPDATE `user` SET `age` = age * 2 + 100  WHERE `user`.`id` = 1
	// 年龄减法
	db.Debug().Model(&user).UpdateColumn("age", gorm.Expr("age - ?", "2")) //UPDATE `user` SET `age` = age - '2'  WHERE `user`.`id` = 1
	// 给符合查询条件的用户年龄-1
	db.Debug().Model(&user).Where("age > 10").UpdateColumn("age", gorm.Expr("age - ?", 1)) //UPDATE `user` SET `age` = age - 1  WHERE `user`.`id` = 1 AND ((age > 10))

}
```

### 7，修改Hooks中的值

如果你想修改 `BeforeUpdate`, `BeforeSave` 等 Hooks 中更新的值，你可以使用 `scope.SetColumn`, 例如：

```go
func (user *User) BeforeSave(scope *gorm.Scope) (err error) {
  if pw, err := bcrypt.GenerateFromPassword(user.Password, 0); err == nil {
    scope.SetColumn("EncryptedPassword", pw)
  }
}
```

### 8，其它更新选项

```go
// 为 update SQL 添加其它的 SQL
db.Model(&user).Set("gorm:update_option", "OPTION (OPTIMIZE FOR UNKNOWN)").Update("name", "hello")
//// UPDATE users SET name='hello', updated_at = '2013-11-17 21:34:10' WHERE id=111 OPTION (OPTIMIZE FOR UNKNOWN);
```

## 10，删除

### 1，删除记录

**警告** 删除记录时，请确保主键字段有值，GORM 会通过主键去删除记录，如果主键为空，GORM 会删除该 model 的所有记录。

```go
// 删除现有记录
db.Delete(&email)
//// DELETE from emails where id=10;

// 为删除 SQL 添加额外的 SQL 操作
db.Set("gorm:delete_option", "OPTION (OPTIMIZE FOR UNKNOWN)").Delete(&email)
//// DELETE from emails where id=10 OPTION (OPTIMIZE FOR UNKNOWN);
```

### 2，批量删除

删除全部匹配的记录

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name   string
	Age    int64
	Active bool
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)

	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})

	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20, Active: true}
	//	//db.Create(&u1)
	//	//u2 := User{Name: "jinzhu", Age: 22, Active: false}
	//	//db.Create(&u2)
	//	//u3 := User{Name: "eryajf2", Age: 20, Active: true}
	//	//db.Create(&u3)
	//	//u4 := User{Name: "jinzhu2", Age: 22, Active: false}
	//	//db.Create(&u4)

	// 删除符合条件的记录
	db.Debug().Where("name LIKE ?", "%jinzhu%").Delete(User{}) //UPDATE `user` SET `deleted_at`='2020-03-08 23:48:05'  WHERE `user`.`deleted_at` IS NULL AND ((name LIKE 'jinzhu'))
	// 与上边效果一样
	db.Debug().Delete(User{}, "name LIKE ?", "%jinzhu%") //UPDATE `user` SET `deleted_at`='2020-03-08 23:49:34'  WHERE `user`.`deleted_at` IS NULL AND ((name LIKE '%jinzhu%'))

}
```

### 3，软删除

如果一个 model 有 `DeletedAt` 字段，他将自动获得软删除的功能！ 当调用 `Delete` 方法时， 记录不会真正的从数据库中被删除， 只会将`DeletedAt` 字段的值会被设置为当前时间

```go
db.Delete(&user)
//// UPDATE users SET deleted_at="2013-10-29 10:23" WHERE id = 111;

// 批量删除
db.Where("age = ?", 20).Delete(&User{})
//// UPDATE users SET deleted_at="2013-10-29 10:23" WHERE age = 20;

// 查询记录时会忽略被软删除的记录
db.Where("age = 20").Find(&user)
//// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;

// Unscoped 方法可以查询被软删除的记录
db.Unscoped().Where("age = 20").Find(&users)
//// SELECT * FROM users WHERE age = 20;
```

### 4，物理删除

```go
// Unscoped 方法可以物理删除记录
db.Unscoped().Delete(&order)
//// DELETE FROM orders WHERE id=10;
```

代码示例：

```go
package main

import (
	"fmt"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// 定义模型
type User struct {
	gorm.Model
	Name   string
	Age    int64
	Active bool
}

func main() {
	db, err := gorm.Open("mysql", "root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		panic(err)
	}
	defer db.Close()
	// 默认情况下，gorm创建的表将会是结构体名称的复数形式，如果不想让它自动复数，可以加一下禁用
	db.SingularTable(true)

	// 2, 把模型与数据库中的表对应起来
	db.AutoMigrate(&User{})

	// 3, 创建
	//u1 := User{Name: "eryajf", Age: 20, Active: true}
	//	//db.Create(&u1)
	//	//u2 := User{Name: "jinzhu", Age: 22, Active: false}
	//	//db.Create(&u2)
	//	//u3 := User{Name: "eryajf2", Age: 20, Active: true}
	//	//db.Create(&u3)
	//	//u4 := User{Name: "jinzhu2", Age: 22, Active: false}
	//	//db.Create(&u4)

	// 批量删除
	db.Debug().Where("age = ?", 20).Delete(&User{}) //UPDATE `user` SET `deleted_at`='2020-03-08 23:53:03'  WHERE `user`.`deleted_at` IS NULL AND ((age = 20))

	// 查询记录时会忽略被软删除的记录
	var user User
	db.Debug().Where("age = 20").Find(&user) //SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((age = 20))
	fmt.Println(user)

	// Unscoped 方法可以查询被软删除的记录
	db.Debug().Unscoped().Where("age = 20").Find(&user) //SELECT * FROM `user`  WHERE (age = 20)
	fmt.Println(user)

	// Unscoped 方法可以物理删除记录
	db.Debug().Unscoped().Delete(User{}, "name = ?", "eryajf") //DELETE FROM `user`  WHERE (name = 'eryajf')
}
```

## 11，链式操作相关

### 1，链式操作

Method Chaining，Gorm 实现了链式操作接口，所以你可以把代码写成这样：

```go
// 创建一个查询
tx := db.Where("name = ?", "jinzhu")

// 添加更多条件
if someCondition {
  tx = tx.Where("age = ?", 20)
} else {
  tx = tx.Where("age = ?", 30)
}

if yetAnotherCondition {
  tx = tx.Where("active = ?", 1)
}
```

在调用立即执行方法前不会生成`Query`语句，借助这个特性你可以创建一个函数来处理一些通用逻辑。

### 2，立即执行方法

Immediate methods ，立即执行方法是指那些会立即生成`SQL`语句并发送到数据库的方法, 他们一般是`CRUD`方法，比如：

`Create`, `First`, `Find`, `Take`, `Save`, `UpdateXXX`, `Delete`, `Scan`, `Row`, `Rows`…

这有一个基于上面链式方法代码的立即执行方法的例子：

```go
tx.Find(&user)
```

生成的SQL语句如下：

```sql
SELECT * FROM users where name = 'jinzhu' AND age = 30 AND active = 1;
```

### 3，范围

`Scopes`，Scope是建立在链式操作的基础之上的。

基于它，你可以抽取一些通用逻辑，写出更多可重用的函数库。

```go
func AmountGreaterThan1000(db *gorm.DB) *gorm.DB {
  return db.Where("amount > ?", 1000)
}

func PaidWithCreditCard(db *gorm.DB) *gorm.DB {
  return db.Where("pay_mode_sign = ?", "C")
}

func PaidWithCod(db *gorm.DB) *gorm.DB {
  return db.Where("pay_mode_sign = ?", "C")
}

func OrderStatus(status []string) func (db *gorm.DB) *gorm.DB {
  return func (db *gorm.DB) *gorm.DB {
    return db.Scopes(AmountGreaterThan1000).Where("status IN (?)", status)
  }
}

db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(&orders)
// 查找所有金额大于 1000 的信用卡订单

db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(&orders)
// 查找所有金额大于 1000 的 COD 订单

db.Scopes(AmountGreaterThan1000, OrderStatus([]string{"paid", "shipped"})).Find(&orders)
// 查找所有金额大于 1000 且已付款或者已发货的订单
```

### 4，多个立即执行方法

Multiple Immediate Methods，在 GORM 中使用多个立即执行方法时，后一个立即执行方法会复用前一个**立即执行方法**的条件 (不包括内联条件) 。

```go
db.Where("name LIKE ?", "jinzhu%").Find(&users, "id IN (?)", []int{1, 2, 3}).Count(&count)
```

生成的 Sql

```sql
SELECT * FROM users WHERE name LIKE 'jinzhu%' AND id IN (1, 2, 3)

SELECT count(*) FROM users WHERE name LIKE 'jinzhu%'
```
